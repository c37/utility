{"version":3,"file":"main.min.js","sources":["../src/backend/management/authentication.js","../src/backend/management/authorization/jwt-strategy.js","../src/backend/management/index.js","../src/backend/management/authorization/cuc-strategy.js","../src/backend/management/authorization.js","../src/backend/persistence/databases/dynamo.js","../src/backend/persistence/databases/index.js","../src/backend/persistence/repositories/index.js","../src/backend/persistence/repositories/abstract.js","../src/backend/index.js","../src/backend/persistence/index.js","../src/backend/persistence/unity-of-work.js","../src/frontend/index.js","../src/frontend/hooks/index.js","../src/frontend/hooks/use-update.js","../src/utility/index.js","../src/utility/math.js","../src/utility/string.js","../src/utility/function.js","../src/utility/network.js","../src/utility/http.js"],"sourcesContent":["const validate = (resolver) => {\n  const baseResolver = resolver;\n\n  baseResolver.validate = (childResolver) => {\n    const newResolver = async (parent, args, context, info) => {\n      await resolver(parent, args, context, info);\n\n      return childResolver(parent, args, context, info);\n    };\n\n    return validate(newResolver);\n  };\n\n  return baseResolver;\n};\n\nexport default validate((_, __, { auth }) => {\n  if (!auth || !auth.authenticated) {\n    const {\n      message = \"Not Authenticated\",\n      code = \"NOT_AUTHENTICATED\",\n      status = 401,\n    } = auth || {};\n\n    const error = new Error(message);\n\n    error.code = code;\n    error.status = status;\n\n    throw error;\n  }\n});\n","const jwt = require(\"jsonwebtoken\");\n\nconst { SECRET } = process.env;\n\nexport default (token) => {\n  if (!token) {\n    const error = new Error(\"The api token is missing\");\n\n    error.code = \"MISSING_TOKEN\";\n    error.status = 401;\n\n    throw error;\n  }\n\n  let verify = null;\n  let authenticated = false;\n\n  const parts = token.split(\" \");\n\n  if (!parts.length === 2) {\n    const error = new Error(\"The api token is invalid\");\n\n    error.code = \"INVALID_TOKEN\";\n    error.status = 401;\n\n    throw error;\n  }\n\n  const [type, data] = parts;\n\n  if (type !== \"Bearer\") {\n    const error = new Error(\"The api token is malformatted\");\n\n    error.code = \"MALFORMATTED_TOKEN\";\n    error.status = 401;\n\n    throw error;\n  }\n\n  try {\n    verify = jwt.verify(data, SECRET);\n    authenticated = !!verify;\n  } catch (err) {}\n\n  return {\n    ...verify,\n    authenticated,\n  };\n};\n","import authentication from \"./authentication\";\nimport Authorization from \"./authorization\";\n\nimport cucAuthorizationStrategy from \"./authorization/cuc-strategy\";\nimport jwtAuthorizationStrategy from \"./authorization/jwt-strategy\";\n\nexport default {\n  cucAuthorizationStrategy,\n  jwtAuthorizationStrategy,\n  authentication,\n  Authorization,\n};\n","export default (data) => {\n  if (!data) {\n    const error = new Error(\"The cuc is missing\");\n\n    error.code = \"MISSING_CUC\";\n    error.status = 401;\n\n    throw error;\n  }\n\n  return {\n    account: data,\n    authenticated: true,\n  };\n};\n","export default class Authorization {\n  constructor(authorizationStrategy) {\n    this.authorization = authorizationStrategy;\n  }\n\n  verify(data) {\n    return this.authorization(data);\n  }\n}\n","import { config, DynamoDB } from \"aws-sdk\";\n\nconst IS_OFFLINE = process.env.IS_OFFLINE;\n\nexport default class Dynamo {\n  constructor(\n    settings = {\n      convertEmptyValues: true,\n    }\n  ) {\n    // connect to local DB if running offline\n    if (IS_OFFLINE) {\n      settings.region = \"localhost\";\n      settings.endpoint = \"http://localhost:4040\";\n      settings.accessKeyId = \"DEFAULT_ACCESS_KEY\";\n      settings.secretAccessKey = \"DEFAULT_SECRET\";\n    }\n    config.update(settings);\n    try {\n      const dynamo = new DynamoDB();\n\n      const client = new DynamoDB.DocumentClient();\n\n      Object.assign(this, { client, dynamo });\n    } catch (error) {\n      console.error(error);\n\n      throw error;\n    }\n  }\n\n  static parseOperator(operator) {\n    switch (operator) {\n      case \"startswith\":\n        return \"BEGINS_WITH\";\n      case \"contains\":\n        return \"CONTAINS\";\n      case \"in\":\n        return \"IN\";\n      case \"between\":\n        return \"BETWEEN\";\n      case \"neq\":\n        return \"NE\";\n      case \"gt\":\n        return \"GT\";\n      case \"gte\":\n        return \"GE\";\n      case \"lt\":\n        return \"LT\";\n      case \"lte\":\n        return \"LE\";\n      case \"isnotnull\":\n        return \"NOT_NULL\";\n      case \"isnull\":\n        return \"NULL\";\n      default:\n        return \"EQ\";\n    }\n  }\n\n  static parseValue(filter) {\n    try {\n      if (\n        typeof filter.value === \"string\" &&\n        filter.value.includes(\",\") &&\n        filter.operator === \"in\"\n      ) {\n        return filter.value\n          .split(\",\")\n          .map((value) => (filter.type === \"N\" ? parseFloat(value) : value));\n      }\n    } catch (error) {\n      console.error(error, filter);\n      throw error;\n    }\n\n    switch (filter.type) {\n      case \"N\":\n        return [parseFloat(filter.value)];\n      case \"B\":\n        return [!!parseFloat(filter.value)];\n      default:\n        return [filter.value];\n    }\n  }\n\n  static parseFilter(filter) {\n    return filter\n      .filter(({ value }) => !!value)\n      .reduce(\n        (accum, curr) => ({\n          ...accum,\n          [curr.field]: {\n            ComparisonOperator: this.parseOperator(curr.operator),\n            AttributeValueList: this.parseValue(curr),\n          },\n        }),\n        {}\n      );\n  }\n\n  async createTable(tableName, options = {}) {\n    const params = {\n      TableName: tableName,\n      KeySchema: [{ AttributeName: \"id\", KeyType: \"HASH\" }],\n      AttributeDefinitions: [{ AttributeName: \"id\", AttributeType: \"N\" }],\n      ProvisionedThroughput: {\n        ReadCapacityUnits: 5,\n        WriteCapacityUnits: 5,\n      },\n    };\n\n    if (options.indexes) {\n      params.globalIndexes = options.indexes\n        .filter({ type: \"global\" })\n        .keyBy(\"name\")\n        .value();\n      params.secondaryIndexes = options.indexes\n        .filter({ type: \"local\" })\n        .keyBy(\"name\")\n        .value();\n    }\n    try {\n      return this.dynamo.createTable(params).promise();\n    } catch (error) {\n      console.error(error);\n      throw error;\n    }\n  }\n\n  async deleteTable(tableName) {\n    try {\n      return this.dynamo.deleteTable({ TableName: tableName }).promise();\n    } catch (error) {\n      console.error(error);\n      throw error;\n    }\n  }\n\n  withTable(tableName) {\n    this.tableName = tableName;\n\n    return this;\n  }\n\n  async put(data) {\n    try {\n      return await this.client\n        .put({\n          TableName: this.tableName,\n          Item: data,\n        })\n        .promise();\n    } catch (error) {\n      console.error(error, data);\n      throw error;\n    }\n  }\n\n  // async updateByKey(key, data) {\n  //   const dataClean = omitBy(\n  //     data,\n  //     (item, keyName) => Object.keys(key).includes(keyName) || isNil(item)\n  //   );\n  //   const dataAttrs = Object.keys(dataClean);\n  //   const expressionAttributeNames = dataAttrs.reduce(\n  //     (acc, keyName) => ({\n  //       ...acc,\n  //       [`#${keyName}`]: keyName,\n  //     }),\n  //     {}\n  //   );\n\n  //   const updateExpression = `set ${dataAttrs\n  //     .map((keyName) => `#${keyName} = :${keyName}`)\n  //     .join(\", \")}`;\n\n  //   const expressionAttributeValues = dataAttrs.reduce(\n  //     (acc, keyName) => ({\n  //       ...acc,\n  //       [`:${keyName}`]: dataClean[keyName],\n  //     }),\n  //     {}\n  //   );\n\n  //   return this.update(key, {\n  //     updateExpression,\n  //     expressionAttributeNames,\n  //     expressionAttributeValues,\n  //   });\n  // }\n\n  async update(\n    key,\n    {\n      updateExpression,\n      expressionAttributeNames,\n      expressionAttributeValues,\n      returnValues = \"UPDATED_NEW\",\n    }\n  ) {\n    const params = {\n      TableName: this.tableName,\n      Key: key,\n      UpdateExpression: updateExpression,\n      ExpressionAttributeNames: expressionAttributeNames,\n      ExpressionAttributeValues: expressionAttributeValues,\n      ReturnValues: returnValues,\n    };\n\n    try {\n      const result = await this.client.update(params).promise();\n\n      return result.Attributes;\n    } catch (error) {\n      console.error(error);\n\n      throw error;\n    }\n  }\n\n  async delete(key, condition) {\n    const params = {\n      TableName: this.tableName,\n      Key: key,\n    };\n\n    if (condition) {\n      (params.ConditionExpression = condition.expression),\n        (params.ExpressionAttributeValues = condition.values);\n    }\n\n    await this.client.delete(params).promise();\n\n    return true;\n  }\n\n  async findByKey(key) {\n    const params = {\n      TableName: this.tableName,\n      Key: key,\n    };\n\n    const result = await this.client.get(params).promise();\n\n    return result.Item;\n  }\n\n  async get(key) {\n    const params = {\n      TableName: this.tableName,\n      Key: key,\n    };\n\n    const result = await this.client.get(params).promise();\n\n    return result.Item;\n  }\n\n  async findAll() {\n    const response = await this.client\n      .scan({\n        TableName: this.tableName,\n      })\n      .promise();\n\n    return response.Items;\n  }\n\n  async filter({\n    indexName = null,\n    filter = null,\n    limit = null,\n    skip = null,\n    sort = null,\n    attributesToGetString = null,\n    lean = false,\n  }) {\n    const {\n      KeyConditionExpression,\n      ExpressionAttributeNames,\n      ExpressionAttributeValues,\n      FilterExpression,\n    } = parseFilterToExpressions(filter);\n\n    const params = removeEmptyStringAndNullElements({\n      TableName: this.tableName,\n      IndexName: indexName,\n      KeyConditionExpression,\n      ExpressionAttributeNames,\n      ExpressionAttributeValues,\n      FilterExpression,\n      ProjectionExpression: attributesToGetString,\n    });\n\n    const { Count: count } = await this.client\n      .query({\n        ...params,\n        Select: \"COUNT\",\n      })\n      .promise();\n\n    if (sort) {\n      params.ScanIndexForward = sort.dir !== \"desc\";\n    }\n\n    if (limit) {\n      params.Limit = limit;\n    }\n\n    if (skip) {\n      params.ExclusiveStartKey = skip;\n    }\n\n    let response = await this.client.query(params).promise();\n    let items = [...response.Items];\n\n    process.env.STAGE === \"test\" && console.log(\"params\", params);\n    process.env.STAGE === \"test\" && console.log(\"response\", response);\n\n    if (response.LastEvaluatedKey) {\n      while (response.LastEvaluatedKey) {\n        params.ExclusiveStartKey = response.LastEvaluatedKey;\n        response = await this.client.query(params).promise();\n\n        process.env.STAGE === \"test\" && console.log(\"w - params\", params);\n        process.env.STAGE === \"test\" && console.log(\"w - response\", response);\n\n        if (limit && items.length + response.Items.length > limit) {\n          const itensToCopy = limit - items.length;\n\n          items = items.concat(response.Items.slice(0, itensToCopy));\n\n          response.LastEvaluatedKey = null;\n        } else {\n          items = items.concat(response.Items);\n        }\n      }\n    }\n\n    return {\n      count,\n      items,\n    };\n  }\n}\n\nconst removeEmptyStringAndNullElements = (obj) => {\n  for (const prop in obj) {\n    if (typeof obj[prop] === \"object\" && obj[prop] !== null) {\n      // dive deeper in\n      if (!Object.keys(obj[prop]).length) {\n        delete obj[prop];\n      } else {\n        removeEmptyStringAndNullElements(obj[prop]);\n      }\n    } else if (\n      obj[prop] === \"\" ||\n      obj[prop] === null ||\n      obj[prop] === undefined\n    ) {\n      // delete elements that are empty strings\n      delete obj[prop];\n    }\n  }\n  return obj;\n};\n\nconst parseConditionalExpression = ({ type, operator, field, value }) => {\n  if (\"A\".includes(type)) {\n    let result = \"(\";\n\n    value.forEach((item, idx) => {\n      result += `contains(#${field}, :${field}${idx})`;\n\n      result += idx !== value.length - 1 ? \" or \" : \"\";\n    });\n\n    return result + \")\";\n  }\n\n  switch (operator) {\n    case \"startswith\":\n      return `begins_with(#${field}, :${field})`;\n    case \"contains\":\n      return `contains(#${field}, :${field})`;\n    case \"in\":\n      return `#${field} IN (${value\n        .split(\",\")\n        .map((_, index) => `:${field}${index}`)\n        .join(\",\")})`;\n    case \"between\":\n      return `#${field} BETWEEN ${value\n        .split(\",\")\n        .map((_, index) => `:${field}${index}`)\n        .join(\" AND \")}`;\n    case \"neq\":\n      return `#${field} <> :${field}`;\n    case \"gt\":\n      return `#${field} > :${field}`;\n    case \"gte\":\n      return `#${field} >= :${field}`;\n    case \"lt\":\n      return `#${field} < :${field}`;\n    case \"lte\":\n      return `#${field} <= :${field}`;\n    case \"isnotnull\":\n      return `NOT attribute_type(#${field}, :${field})`;\n    case \"isnull\":\n      return `attribute_type(#${field}, :${field})`;\n    default:\n      return `#${field} = :${field}`;\n  }\n};\n\nconst genMapFieldsIn = (rootAcc, commaStr, keyPrefix, fieldName, fieldType) => {\n  return {\n    ...rootAcc,\n    ...commaStr.split(\",\").reduce(\n      (acc, value, index) => ({\n        ...acc,\n        [`${keyPrefix}${fieldName}${index}`]:\n          fieldType === \"N\" ? parseFloat(value) : value,\n      }),\n      {}\n    ),\n  };\n};\n\nconst genMapFields = (\n  filters = [],\n  keyPrefix = \"#\",\n  keyName = \"field\",\n  keyValueName = \"field\"\n) => {\n  return filters.reduce((acc, item) => {\n    const isValue = keyPrefix === \":\";\n\n    if (isValue && [\"isnotnull\", \"isnull\"].includes(item.operator)) {\n      return { ...acc, [`${keyPrefix}${item[keyName]}`]: \"NULL\" };\n    }\n    if (isValue && [\"between\", \"in\"].includes(item.operator)) {\n      return genMapFieldsIn(acc, item.value, keyPrefix, item.field, item.type);\n    }\n\n    if (isValue && \"A\".includes(item.type)) {\n      let result = { ...acc };\n\n      item.value.forEach((itemValue, idx) => {\n        result[`${keyPrefix}${item[keyName]}${idx}`] = itemValue;\n      });\n\n      return result;\n    }\n\n    return {\n      ...acc,\n      [`${keyPrefix}${item[keyName]}`]: !isValue\n        ? item[keyValueName]\n        : item.type === \"N\"\n        ? parseFloat(item[keyValueName])\n        : item.type === \"B\"\n        ? item[keyValueName] === \"true\"\n        : item[keyValueName],\n    };\n  }, {});\n};\n\nconst parseFilterToExpressions = (filters = []) => {\n  // filters = filters.filter(({ operator, value }) => [\"isnotnull\", \"isnull\"].includes(operator) || !!value );\n\n  const keysFieldsSelected = [];\n\n  const keyConditionExpression = filters.filter(\n    ({ operator, isKey, field }, index) => {\n      if (\n        (isKey || index === 0) &&\n        (!operator ||\n          ![\"startswith\", \"contains\", \"in\", \"neq\"].includes(operator))\n      ) {\n        return keysFieldsSelected.push(field) > 0;\n      }\n      return false;\n    }\n  );\n\n  const filterExpression = filters.filter(\n    ({ field }) => !keysFieldsSelected.includes(field)\n  );\n  const ExpressionAttributeNames = genMapFields(filters, \"#\", \"field\", \"field\");\n\n  const KeyConditionExpression = `${keyConditionExpression\n    .map(parseConditionalExpression)\n    .join(\" and \")}`;\n\n  const FilterExpression = `${filterExpression\n    .map(parseConditionalExpression)\n    .join(\" and \")}`;\n\n  const ExpressionAttributeValues = genMapFields(\n    filters,\n    \":\",\n    \"field\",\n    \"value\"\n  );\n  return {\n    KeyConditionExpression,\n    ExpressionAttributeNames,\n    ExpressionAttributeValues,\n    FilterExpression,\n  };\n};\n","import Dynamo from \"./dynamo\";\n\nexport default { Dynamo };\n","import AbstractRepository from \"./abstract\";\n\nexport default class Repository extends AbstractRepository {\n  constructor(database, tableName) {\n    super(database, tableName);\n  }\n}\n","export default class AbstractRepository {\n  constructor(database, tableName) {\n    Object.assign(this, { database, tableName });\n  }\n\n  async findByKey(id) {\n    return this.database.withTable(this.tableName).findByKey(id);\n  }\n\n  async findAll() {\n    return this.database.withTable(this.tableName).findAll();\n  }\n\n  async filter({\n    indexName,\n    limit,\n    skip,\n    sort,\n    filter,\n    attributesToGetString,\n  }) {\n    return this.database.withTable(this.tableName).filter({\n      indexName,\n      limit,\n      skip,\n      sort,\n      filter,\n      attributesToGetString,\n    });\n  }\n\n  async put(data) {\n    return this.database.withTable(this.tableName).put(data);\n  }\n\n  async delete(key) {\n    return this.database.withTable(this.tableName).delete(key);\n  }\n}\n","import management from \"./management\";\nimport persistence from \"./persistence\";\n\nexport default { management, persistence };\n","import databases from \"./databases\";\nimport UnitOfWork from \"./unity-of-work\";\n\nexport default { databases, UnitOfWork };\n","import Repository from \"./repositories\";\n\nexport default class UnitOfWork {\n  constructor(database, tableName) {\n    Object.assign(this, { database, tableName });\n\n    this.constructor.container = new Map();\n  }\n\n  repository() {\n    const { container } = this.constructor;\n\n    const repository = new Repository(this.database, this.tableName);\n\n    container.set(this.tableName, repository);\n\n    return repository;\n  }\n}\n","import hooks from \"./hooks\";\n\nexport default { hooks };\n","import useUpdate from \"./use-update\";\n\nexport default { useUpdate };\n","// https://stackoverflow.com/a/53180013/8589328\nimport { useRef, useEffect } from \"react\";\n\nexport default (fn, inputs) => {\n  const didMountRef = useRef(false);\n\n  useEffect(() => {\n    if (didMountRef.current) fn();\n    else didMountRef.current = true;\n  }, inputs);\n};\n","import math from \"./math\";\nimport string from \"./string\";\nimport func from \"./function\";\nimport network from \"./network\";\nimport http from \"./http\";\n\nexport default { math, string, func, network, http };\n","export default {\n  // http://www.ietf.org/rfc/rfc4122.txt\n  guid: function guid(length, radix) {\n    var chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\".split(\n        \"\"\n      ),\n      uuid = [],\n      i;\n    radix = radix || chars.length;\n\n    if (length) {\n      for (i = 0; i < length; i++) {\n        uuid[i] = chars[0 | (Math.random() * radix)];\n      }\n    } else {\n      var r;\n\n      uuid[8] = uuid[13] = uuid[18] = uuid[23] = \"-\";\n      uuid[14] = \"4\";\n\n      for (i = 0; i < 36; i++) {\n        if (!uuid[i]) {\n          r = 0 | (Math.random() * 16);\n          uuid[i] = chars[i == 19 ? (r & 0x3) | 0x8 : r];\n        }\n      }\n    }\n\n    return uuid.join(\"\").toLowerCase();\n  },\n};\n","export default {\n  // https://stackoverflow.com/questions/36637146/javascript-encode-string-to-hex\n  toHex: function (tmp) {\n    var str = \"\";\n    for (var i = 0; i < tmp.length; i++) {\n      str += tmp[i].charCodeAt(0).toString(16);\n    }\n    return str;\n  },\n  // https://flaviocopes.com/how-to-uppercase-first-letter-javascript/\n  capitalize: function (str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  },\n};\n","export default {\n  // https://davidwalsh.name/javascript-debounce-function\n  debounce: function (func, wait, immediate) {\n    var timeout;\n    return function () {\n      var context = this,\n        args = arguments;\n      var later = function () {\n        timeout = null;\n        if (!immediate) func.apply(context, args);\n      };\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) func.apply(context, args);\n    };\n  },\n};\n","export default {\n  // http://ccoenraets.github.io/es6-tutorial-data/promisify/\n  // http://stackoverflow.com/questions/28921127/how-to-wait-for-a-javascript-promise-to-resolve-before-resuming-function\n  // https://developer.mozilla.org/pt-BR/docs/Web/API/XMLHttpRequest\n  request: function (obj) {\n    return new Promise(function (resolve, reject) {\n      var xhr = new XMLHttpRequest();\n      xhr.open(obj.method || \"GET\", obj.url);\n      if (obj.headers) {\n        Object.keys(obj.headers).forEach(function (key) {\n          xhr.setRequestHeader(key, obj.headers[key]);\n        });\n      }\n      xhr.onload = function () {\n        // console.log(xhr.getAllResponseHeaders());\n\n        // https://en.wikipedia.org/wiki/List_of_HTTP_status_codes\n        resolve({\n          code: xhr.status,\n          message: xhr.response || xhr.responseText,\n        });\n\n        // if (xhr.status >= 200 && xhr.status < 300) {\n        //     resolve(xhr.response);\n        // } else {\n        //     reject(xhr.statusText);\n        // }\n      };\n\n      xhr.onerror = function () {\n        reject(xhr.statusText);\n      };\n      xhr.send(obj.body);\n    });\n  },\n  info: {\n    data: null,\n    load: function () {\n      utility.net\n        .request({\n          // url:\n          //   \"http://api.ipstack.com/check?access_key=4e033eb864b6a92fa9027da214a67ccc&format=1\"\n          // url: \"https://freegeoip.net/json/\"\n          url: \"https://ipapi.co/json/\",\n        })\n        .then(function (data) {\n          if (data.code === 200) {\n            utility.net.info.data = JSON.parse(data.message);\n            // console.log(utility.net.info.data)\n          }\n        })\n        .catch(function (error) {\n          utility.net.info.data = {};\n        });\n    },\n  },\n};\n","export default {\n  response: (payload, type = \"json\") => {\n    if (type === \"json\") {\n      return {\n        statusCode: 200,\n        body: JSON.stringify({\n          payload,\n        }),\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      };\n    } else {\n      return {\n        statusCode: 200,\n        body: payload,\n        isBase64Encoded: true,\n        headers: {\n          \"Access-Control-Allow-Origin\": \"*\",\n          \"Content-disposition\": `attachment; filename=${new Date().toISOString()}.${\n            type === \"img\" ? \"jpg\" : \"pdf\"\n          }`,\n          \"Content-Type\": type === \"img\" ? \"image/jpg\" : \"application/pdf\",\n        },\n      };\n    }\n  },\n  size: (base64String) => {\n    let padding, inBytes, base64StringLength;\n    if (base64String.endsWith(\"==\")) padding = 2;\n    else if (base64String.endsWith(\"=\")) padding = 1;\n    else padding = 0;\n\n    base64StringLength = base64String.length;\n    inBytes = (base64StringLength / 4) * 3 - padding;\n    const kbytes = inBytes / 1000;\n    return kbytes;\n  },\n};\n"],"names":["validate","resolver","baseResolver","childResolver","async","parent","args","context","info","_","__","auth","authenticated","message","code","status","error","Error","jwt","require","SECRET","process","env","cucAuthorizationStrategy","data","account","jwtAuthorizationStrategy","token","verify","parts","split","length","type","err","authentication","Authorization","[object Object]","authorizationStrategy","this","authorization","Dynamo","aws","Repository","database","tableName","Object","assign","id","withTable","findByKey","findAll","indexName","limit","skip","sort","filter","attributesToGetString","put","key","delete","super","management","persistence","databases","UnitOfWork","constructor","container","Map","repository","set","hooks","useUpdate","react","math","guid","radix","i","r","chars","uuid","Math","random","join","toLowerCase","string","toHex","tmp","str","charCodeAt","toString","capitalize","charAt","toUpperCase","slice","func","debounce","wait","immediate","timeout","arguments","later","apply","callNow","clearTimeout","setTimeout","network","request","obj","Promise","resolve","reject","xhr","XMLHttpRequest","open","method","url","headers","keys","forEach","setRequestHeader","onload","response","responseText","onerror","statusText","send","body","load","utility","net","then","JSON","parse","catch","http","payload","statusCode","stringify","Content-Type","isBase64Encoded","Access-Control-Allow-Origin","Content-disposition","Date","toISOString","size","base64String","padding","inBytes","base64StringLength","endsWith"],"mappings":"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"}